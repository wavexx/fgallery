#!/usr/pkg/bin/perl
# fgallery: a modern, minimalist javascript photo gallery
# Copyright(c) 2011-2016 by wave++ "Yuri D'Elia" <wavexx@thregr.org>
# Distributed under GPLv2+ (see COPYING) WITHOUT ANY WARRANTY.
use v5.14;
use strict;
use warnings;

use locale;
use utf8;
use if $^V lt v5.23.4, open => qw{:std :utf8};
use if $^V ge v5.23.4, open => qw{:std :locale};
require Encode;
require encoding;

use threads;
use threads::shared;
use Thread::Queue;
use Storable qw{freeze thaw};
use Fcntl;

use File::Basename qw{fileparse};
use File::Find qw{find};
use File::Path qw{make_path remove_tree};
use File::Spec::Functions qw{rel2abs canonpath catfile splitpath};
use Getopt::Long qw{:config bundling};
use IO::Handle;
use Image::ExifTool qw{ImageInfo};
use Time::Piece;

use JSON::PP;

# constants
our $VERSION = "2.0.0";
our $ENCODING = encoding::_get_locale_encoding() || 'UTF-8';

# where the view subdirectory lives (JavaScript and CSS code)
our $ShareDir = '/usr/pkg/share/fgallery';

# directory creation mask
umask oct('0022');

# defaults
my (undef, undef, $me) = splitpath($0);
my $filemode = oct('0644');
my $slim = 0;
my $ofile = 0;
my $orient = 1;
my $timesort = 1;
my $revsort = 0;
my @filetypes = ("JPEG", "PNG", "TIFF");
my @exts = ("jpg", "jpeg", "png", "tif", "tiff");
my $ext = "jpg";
my @minthumb = (150, 112);
my @maxthumb = (267, 200);
my @maxfull = (1600, 1200);
my $imgq = 90;
my $fullpano = 1;
my $nodown = 0;
my $panort = 2.;
my $facedet = 0;
my $keeporig = 0;
my $jpegoptim = 1;
my $pngoptim = 1;
my $p7zip = 1;
my $verbose = 0;
my $workers = 0;
my $sRGB = 1;
my $do_blur = 1;
my $indexUrl = undef;
my @capmethods = ("txt", "xmp", "exif");
my $galleryTitle = "";
my $galleryDescription = "";
my $galleryUrl = "";
my $update = 0;
my @copy_method_ok = qw(copy hard sym ref);
my $copy_method_default = 'copy';
my $copy_method = $copy_method_default;


# support functions
sub fatal
{
  die map { "$_\n" } 'Fatal error:', @_;
}


# see if our environment has a given command installed
sub cmd_exists
{
  my ($c) = @_;
  return qx{/bin/sh -c "command -v $c"};
}


sub sys
{
  my @cmd = @_;

  warn join(" ", '+', @cmd) . "\n" if $verbose;

  my $fd;
  unless(open($fd, '-|', @cmd)) {
    fatal("cannot execute \"$cmd[0]\"");
  }

  local $/ = undef;
  my $o = <$fd>;

  unless(close($fd)) {
    fatal("command \"@cmd\" failed");
  }

  return split("\n", $o);
}


sub isin
{
  my ($id, @arr) = @_;
  foreach my $c(@arr) {
    return 1 if $c eq $id;
  }
  return 0;
}


sub is_fgallery_dir
{
    my ($d) = @_;
    return unless -e catfile($d, 'view');
    return unless -e catfile($d, 'index.html');
    return unless -e catfile($d, 'data.json');
    return 1;
}


sub slurp
{
  my ($fn) = @_;
  open(my $fd, '<', $fn) or fatal("cannot read $fn: $!");
  if ($^V lt v5.23.4) {
    binmode($fd, ":encoding($ENCODING)");
  }
  local $/;
  return <$fd> // "";
}


sub dispatch
{
  my ($fun, @seq) = @_;
  my $workers = $workers || 1;

  my $queue = Thread::Queue->new();
  for my $v(@seq) {
    $queue->enqueue($v);
  }

  my @threads;
  foreach my $n(1 .. $workers)
  {
    my $thr = threads->create(sub
    {
      while(defined(my $v = $queue->dequeue_nb())) {
        &$fun($v);
      }
    });
    push(@threads, $thr);
  }

  foreach my $thr(@threads) {
    $thr->join();
  }
}


sub par_map
{
  my ($fun, @seq) = @_;

  my $n = @seq;
  my @idx = 0 .. $n - 1;
  my @res :shared = (undef) x $n;

  dispatch(
    sub {
      my $i = shift;
      my $r = &$fun($seq[$i]);
      $res[$i] = defined($r) ? freeze($r) : undef;
    },
    @idx
  );

  return map { thaw $_ } @res;
}


sub min
{
  my ($a, $b) = @_;
  return ($a < $b? $a: $b);
}


sub max
{
  my ($a, $b) = @_;
  return ($a > $b? $a: $b);
}


sub clamp
{
  my ($a, $b, $v) = @_;
  return ($v < $a? $a: $v > $b? $b: $v);
}


sub decode
{
  return Encode::decode($ENCODING, $_[0]);
}


sub encode
{
  return Encode::encode($ENCODING, $_[0]);
}


# thread-safe progress bar
{
  package progress;

  my $act :shared;
  my $total :shared;
  my $cnt :shared;
  my $llen :shared;

  sub init
  {
    my ($_act, $_total) = @_;
    $act = $_act;
    $total = $_total;
    $cnt = 0;
    $llen = 0;
    print(pad($act . ' ...') . "\r");
    STDOUT->flush();
  }

  sub pad
  {
    my ($str) = @_;
    my $len = length($str);
    $str .= " " x ($llen - $len) if $len < $llen;
    $llen = $len;
    return $str;
  }

  sub status
  {
    my ($msg) = @_;
    lock($cnt);

    my $pc = ($cnt++ / $total * 100);
    my $str = sprintf("%s %2.0f%%", $act, $pc);
    $str .= ": " . $msg if $msg;
    print pad($str) . "\r";
    STDOUT->flush();
  }

  sub done
  {
    print(pad($act . ' completed') . "\n");
  }
}


# caption utilities
sub cap_clean
{
  my ($x) = @_;
  return '' unless $x;
  $x =~ s/^\s+|\s+$//go;
  $x =~ s/\s+/ /go;
  return $x;
}

sub cap_from_str
{
  my ($title, $desc) = @_;
  return unless $title;
  ($title, $desc) = split /\n+/o, $title unless $desc;
  return [cap_clean($title), cap_clean($desc)];
}

sub cap_from_props
{
  my ($props) = @_;
  my $ret = ['', ''];
  if ($props->{'Title'})
  {
    my $title = Encode::decode_utf8($props->{'Title'});
    $ret->[0] = cap_clean($title);
  }
  if ($props->{'Description'})
  {
    my $desc = Encode::decode_utf8($props->{'Description'});
    $ret->[1] = cap_clean($desc);
  }
  return $ret;
}


# options
sub parse_wh
{
  my ($opt, $spec) = @_;
  my ($w, $h) = ($spec =~ /^(\d+)x(\d+)$/);
  unless(defined($w) && $w > 0 && defined($h) && $h > 0) {
    fatal("bad WxH specification in option $opt");
  }
  return (int($w), int($h));
}

sub parse_int
{
  my ($opt, $value, $min, $max) = @_;
  if ((defined($min) && $value < $min) || (defined($max) && $value > $max)) {
    fatal("bad value for option $opt");
  }
  return int($value);
}

sub parse_cap
{
  my ($opt, $value) = @_;
  return () if $value eq "none";
  my @capmethods = split(",", $value);
  foreach my $m(@capmethods)
  {
    if (!isin($m, ("txt", "xmp", "exif", "cmt"))) {
      fatal("invalid caption extraction method: $m");
    }
  }
  return @capmethods;
}

sub parse_copy_method
{
  my ($o, $v) = @_;
  $v = $copy_method_default unless $v;
  fatal "'$v' not a copy method; use one of ", join ', ', @copy_method_ok
    unless isin($v, @copy_method_ok);
  return $v;
}

sub init_noscript
{
  my ($d) = @_;
  fatal("init_noscript: $d not a directory")
    unless $d && -d $d;
  my $fd;
  my $f = "$d/noscript.html";
  unless(open($fd, ">:raw", $f)) {
    fatal("init_noscript: cannot write file '$f': $!");
  }
  chmod($filemode, $f);
  select $fd;
  print join "\n",
    '<!DOCTYPE html>',
    '<html>',
    '<head>',
    '  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />',
    '  <meta name="viewport" '
       . 'content="width=device-width,initial-scale=1,'
       . 'minimum-scale=1,minimal-ui" />',
    '  <link href="view/noscript.css" rel="stylesheet" type="text/css" />',
    '</head>',
    '<body>',
    '  <section id="photos">',
    '';
}

sub print_noscript
# <a href="imgs/DSC00712.jpg"><img src="thumbs/DSC00712.jpg" alt="c1 c2"></a>
{
  my ($f, $t, $c) = @_;
  return unless @_ == 3 && $f && $t;
  $c = [] unless $c && ref $c eq 'ARRAY';
  my $x = '';
  for (@$c) {
    $x .= ' ' if $c =~ /\S$/o;
    $x .= $_ if defined $_ && /\S/o;
  }
  my $a = '';
  $a = sprintf ' alt="%s"', $x if $x && $x =~ /\S/o;
  printf '    <a href="%s"><img src="%s"%s></a>' . "\n", $f, $t, $a;
}

sub finish_noscript
{
  print join "\n", '  </section>', '</body>', '</html>', '';
  select STDOUT;
}

sub print_help
{
  warn qq{Usage: $me [options] INPUT_DIR OUTPUT_DIR [ALBUM_NAME]
  -h, --help            this help
  --version             output current fgallery version
  -v                    verbose (show commands as being executed)
  -s                    slim output (no original files and downloads)
  -i                    include individual originals
  -c methods            caption extraction methods (txt,xmp,exif,cmt, or none)
  -o                    do not auto-orient
  -k                    do not modify files, keep original
  -t                    do not time-sort
  -r                    reverse album order
  -u                    update existing gallery
  -p                    do not automatically include full-sized panoramas
  -d                    do not generate a full album download
  -f                    improve thumbnail cutting by performing face detection
  -j N                  set process-level parallelism
  --noblur              skip blurry backdrop generation (just dark noise)
  --max-full WxH        maximum full image size ($maxfull[0]x$maxfull[1])
  --max-thumb WxH       maximum thumbnail size ($maxthumb[0]x$maxthumb[1])
  --min-thumb WxH       minimum thumbnail size ($minthumb[0]x$minthumb[1])
  --no-sRGB             do not remap preview/thumbnail color profiles to sRGB
  --quality Q           preview image quality (0-100, currently: $imgq)
  --link-orig           copy method (hard,sym,ref, or copy); default: $copy_method_default
  --index url           URL location for the index/back button
  These options are for Facebook or Twitter and must all be provided:
  --url URL             URL of gallery
  --title "TITLE"       title for Facebook and Twitter previews
  --description "DESC"  description for Facebook and Twitter previews
};
  exit(shift);
}


# main program
@ARGV = map { decode($_) } @ARGV;
my ($rc, @ARGS) = GetOptions(
  'help|h' => sub { print_help(0); },
  'version' => sub { print "$0 $VERSION\n"; exit 0; },
  'c=s' => sub { @capmethods = parse_cap($_[0], $_[1]); },
  'd' => sub { $nodown = 1; },
  'f' => sub { $facedet = 1; },
  'i' => sub { $ofile = 1; },
  'j=i' => sub { $workers = parse_int($_[0], $_[1], 1, undef); },
  'o' => sub { $orient = 0; },
  'k' => sub { $keeporig = 1; },
  'p' => sub { $fullpano = 0; },
  'r' => sub { $revsort = 1; },
  's' => sub { $slim = 1; },
  't' => sub { $timesort = 0; },
  'u' => sub { $update = 1; },
  'v' => sub { $verbose = 1; },
  'noblur' => sub { $do_blur = 0; },
  'max-full=s' => sub { @maxfull = parse_wh(@_); },
  'max-thumb=s' => sub { @maxthumb = parse_wh(@_); },
  'min-thumb=s' => sub { @minthumb = parse_wh(@_); },
  'no-sRGB' => sub { $sRGB = 0; },
  'quality=i' => sub { $imgq = parse_int($_[0], $_[1], 0, 100); },
  'index=s' => sub { $indexUrl = $_[1]; },
  'title=s' => sub { $galleryTitle = $_[1]; },
  'description=s' => sub { $galleryDescription = $_[1]; },
  'url=s' => sub { $galleryUrl = $_[1]; },
  'link-orig:s' => sub { $copy_method = parse_copy_method($_[0], $_[1]); },
);

print_help(2) unless $rc && ((@ARGV == 2) || (@ARGV == 3));

if (($galleryTitle || $galleryDescription || $galleryUrl)
    && !($galleryTitle && $galleryDescription && $galleryUrl)) {
  fatal("all three are required: --title, --description, and --url");
}

my ($dir, $out, $name) = @ARGV;
my $absDir = canonpath(rel2abs($dir)) . '/';
my $absOut = canonpath(rel2abs($out)) . '/';

if (!-d $absDir) {
  fatal("input directory '$absDir' does not exist");
} elsif ($absDir eq $absOut) {
  fatal("input and output directory are the same");
} elsif (substr($absOut, 0, length($absDir)) eq $absDir) {
  fatal("output directory is a sub-directory of input, refusing to scan");
} elsif (!-d $absOut) {
  mkdir $absOut || fatal "Failed to create output directory $absOut";
  if ($copy_method eq 'sym') {
    chdir($absOut) || die "Failed to 'cd $absOut' for symlink creation";
    sys('ln', '-s', catfile($ShareDir, 'view'));
    sys('ln', '-s', catfile('view', 'index.html'));
   } else {
    sys('cp', '-L', '-R', catfile($ShareDir,'view'), $absOut);
    sys('mv', catfile(catfile($absOut,'view'),'index.html'), $absOut);
  }
} elsif (!is_fgallery_dir($absOut)) {
  fatal("output dir '$absOut' exists, but doesn't look like a ${me} dir");
}

# check tools
fatal 'Missing identify or convert executable (from ImageMagick)'
  unless cmd_exists('identify') || cmd_exists('convert');
unless(cmd_exists('7za')) {
  $p7zip = 0;
  cmd_exists('zip') || fatal('Missing 7z or zip command');
}
$jpegoptim = 0 unless cmd_exists('jpegoptim');
$pngoptim = 0 unless cmd_exists('pngcrush');
fatal 'Missing facedetect (see http://www.thregr.org/~wavexx/hacks/facedetect/'
  if $facedet && !cmd_exists('facedetect');
fatal 'Missing tificc executable (from lcms2 library)'
  if $sRGB && !cmd_exists('tificc');
my $tificccmd = 'tificc';
my $exiftrancmd;
while($orient)
{
  $exiftrancmd = "exiftran -aip" if cmd_exists('exiftran');
  last if $exiftrancmd;
  $exiftrancmd = "exifautotran" if cmd_exists('exifautotran');
  fatal 'Missing exiftran or exifautotran executable for JPEG autorotation'
    unless $exiftrancmd;
}

# list available files
my @files;
find(
{
  no_chdir => 1,
  wanted => sub
  {
    my $file = decode($_);
    return unless -f $file;
    my ($base, undef, $suffix) = fileparse($file, qr/\.[^.]*$/);
    return if (length($suffix) < 2 || $base =~ /^\./);
    $suffix = lc(substr($suffix, 1));
    if (isin($suffix, @exts)) {
      push(@files, $file);
    }
  }
}, encode($absDir));
@files = sort(@files);

if (!@files) {
  fatal("no files found in '$absDir'");
}

# derived arguments
my $backblur = int(($minthumb[0] + $minthumb[1]) / 2 * 0.1);
my @backsize = (int($minthumb[0] * 4), int($minthumb[1] * 3));

# cleanup target paths
unless ($update) {
  for ( qw(thumbs blurs imgs files) ) {
    remove_tree(catfile($absOut, $_));
    make_path(catfile($absOut, $_));
  }
}

# disable sub-process parallelism when threading ourselves
if ($workers)
{
  $ENV{MAGICK_THREAD_LIMIT} = 1;
  $ENV{OMP_NUM_THREADS} = 1;
}

# updates require data from the original JSON file
my @odata;
my %ofiles;
if ($update) {
  # FIXME: use slurp but avoid wide character warning?
  my $fn = catfile($absOut, 'data.json');
  open(my $fd, '<:raw', $fn) or fatal("cannot read $fn: $!");
  local $/;
  my $json = <$fd>;
  my $data = decode_json($json);
  @odata = @{$data->{data}};
  foreach(@odata) {
    $ofiles{$_->{img}->[0]} = 1; # this is $fdata{img}
  }
}

# 1st pass: extract/prepare input file data
sub analyze_file
{
  my $file = shift;
  my ($base, $absDir, $suffix) = fileparse(decode($file), qr/\.[^.]*$/);
  $suffix = lc(substr($suffix, 1));

  progress::status("$base.$suffix");

  my $props = ImageInfo($file, {PrintConv => 0, Sort => 'File'});
  return unless defined $props && isin($props->{FileType}, @filetypes);

  # sanitize file name
  my $sane = $base;
  $sane =~ s/[^\w\-]/_/gu;

  my $root = $sane;

  # Skip this file if we're updating and it already exists in the output
  # data.json. FIXME: Need a way to identify existing files with the
  # autoincrement below. For the moment, this breaks for all filenames that
  # result in duplicates after sanitzing.
  return if $update && exists $ofiles{catfile('imgs', "$root.$ext")};

  for(my $c = 0;; ++$c) {
    my $tmp = catfile(catfile($absOut, 'imgs'), "$root.$ext");
    if (sysopen(my $fd, $tmp, O_WRONLY|O_CREAT|O_EXCL, $filemode)) {
      close($fd);
      last;
    }
    $root = "${sane}_$c";
  }

  $props->{file} = $file;
  $props->{root} = $root;
  $props->{suffix} = $suffix;

  # try to fetch the original image size by iterating to the last duplicated tag
  $props->{'OrigImageWidth'} = $props->{'ExifImageWidth'} || undef;
  $props->{'OrigImageHeight'} = $props->{'ExifImageHeight'} || undef;
  for(my $n = 1; exists($props->{"ExifImageWidth ($n)"}); ++$n)
  {
    $props->{'OrigImageWidth'} = $props->{"ExifImageWidth ($n)"};
    $props->{'OrigImageHeight'} = $props->{"ExifImageHeight ($n)"};
  }

  # extract caption
  foreach my $m(@capmethods)
  {
    if ($m eq "cmt")
    {
      if ($props->{'Comment'})
      {
        my $cmt = Encode::decode_utf8($props->{'Comment'});
        $props->{'caption'} = cap_from_str($cmt);
        last;
      }
    }
    elsif ($m eq "txt")
    {
      my $txt = catfile($absDir, $base . '.txt');
      if (-f $txt)
      {
        $props->{'caption'} = cap_from_str(slurp($txt));
        last;
      }
    }
    elsif ($m eq "exif")
    {
      if ($props->{'Title'} || $props->{'Description'})
      {
        $props->{'caption'} = cap_from_props($props);
        last;
      }
    }
    elsif ($m eq "xmp")
    {
      my $xmp = ImageInfo("$file.xmp", {PrintConv => 0, Sort => 'File'});
      if (defined($xmp) && ($xmp->{'Title'} || $xmp->{'Description'}))
      {
        $props->{'caption'} = cap_from_props($xmp);
        last;
      }
    }
  }

  return $props;
}

progress::init("reading", scalar(@files));
my @aprops = par_map(\&analyze_file, @files);
progress::done();

# remove unprocessable files
for(my $n = 0; $n <= $#files;)
{
  if (defined($aprops[$n]))
  {
    ++$n;
    next;
  }
  splice(@files, $n, 1);
  splice(@aprops, $n, 1);
}

unless(@files) {
  fatal("nothing to be done");
}

# gather some statistics
my $amp = 0;
my $ostamp = 0;
foreach my $props(@aprops)
{
  # file timestamp
  my $idate = $props->{'DateTimeOriginal'} || $props->{'DateTime'} || "";
  $idate =~ s/^\s+|\s+$//g;

  my $t = eval { Time::Piece->strptime($idate, "%Y:%m:%d %H:%M:%S"); };
  if (!$t || !$t->epoch)
  {
    # no date available, cheat by using the previous timestamp
    $props->{stamp} = $ostamp = $ostamp + 1;
  }
  else
  {
    $props->{date} = $t->strftime("%Y-%m-%d %H:%M");
    $props->{stamp} = $ostamp = $t->epoch;
  }

  # mp average
  $props->{mp} = ($props->{ImageWidth} * $props->{ImageHeight} / 1e6);
  $amp += $props->{mp};
}
$amp /= @files;

sub copy_source_file
{
  my ($file, $fout) = @_;
  my @options = ('-L');
  my %option = (
    hard => '--link',
    sym  => '--symbolic-link',
    ref  => '--reflink',
  );
  push @options, $option{$copy_method} if $option{$copy_method};

  # symlinks need the right dest path - simplest is to give them an abs path
  $file = rel2abs($file) if $copy_method eq 'sym';

  sys('cp', @options, $file, $fout);

  # adjust file mode on copy methods that create a new inode
  chmod($filemode, $fout) if ($copy_method eq 'copy')
                      || ($copy_method eq 'ref');
}

# 2nd pass: produce output files
sub process_img
{
  my %props = %{shift()};
  my $root = $props{root};
  my $suffix = $props{suffix};
  my $file = $props{file};

  # derived file names
  my $ffile = catfile('files', "$root.$suffix");
  my $fbase = "$root.$ext";
  my $fimg = catfile('imgs', $fbase);
  my $fthumb = catfile('thumbs', $fbase);
  my $fblur = catfile('blurs', $fbase);

  my $absFout = catfile($absOut, $ffile);
  my $absFtmp = catfile($absOut, "$ffile.tmp");

  progress::status($fbase);

  # copy source file
  copy_source_file($file, $absFout);

  # apply lossless transforms
  if (!$keeporig) {
    if ($orient && $props{FileType} eq "JPEG" && ($props{'Orientation'} // 0)) {
      sys("$exiftrancmd $absFout 2>/dev/null");
      if (($props{'Orientation'} // 0) > 4) {
        ($props{ImageWidth}, $props{ImageHeight})
          = ($props{ImageHeight}, $props{ImageWidth});
      }
    }
    if ($jpegoptim && $props{FileType} eq "JPEG") {
      sys('jpegoptim', '-q', $absFout);
    } elsif ($pngoptim && $props{FileType} eq "PNG") {
      sys('pngcrush', '-q', $absFout, $absFtmp);
      rename($absFtmp, $absFout);
    }
  }

  # final file mode
  chmod($filemode, $absFout);
  sys('touch', '-r', $file, $absFout);

  # intermediate sRGB colorspace conversion
  if ( !$sRGB || !defined($props{ProfileID})
              || ($props{ColorSpace} // 65535) == 1
              || ($props{DeviceModel} // '') eq 'sRGB') {
    $absFtmp = $absFout;
  } else {
    sys('convert', '-quiet', $absFout, '-compress', 'LZW',
                   '-type', 'truecolor', "tiff:$absFtmp");
    sys($tificccmd, '-t0', $absFtmp, "$absFtmp.tmp");
    rename("$absFtmp.tmp", $absFtmp);
  }

  # avoid conversion to string
  my @minthumb = @minthumb;
  my @maxthumb = @maxthumb;
  my @backsize = @backsize;

  # generate main image
  my @sfile = ($props{ImageWidth}, $props{ImageHeight});
  my @simg = sys('convert', '-quiet', $absFtmp,
                 '-gamma', '0.454545',
                 '-geometry', "$maxfull[0]x$maxfull[1]>",
                 '-print', '%w\n%h',
                 '-gamma', '2.2',
                 '+profile', '!icc,*',
                 '-quality', $imgq, catfile($absOut, $fimg)
             );

  # face/center detection
  my @center = (0.5, 0.5);
  if ($facedet) {
    my @f = sys("facedetect", "--best", "--center", catfile($absOut, $fimg));
    if (@f) {
      my @tmp = split(" ", $f[0]);
      @center = ($tmp[0] / $simg[0], $tmp[1] / $simg[1]);
    }
  }

  # thumbnail size
  my $thumbrt;
  if ($sfile[0] / $sfile[1] < $minthumb[0] / $minthumb[1]) {
    $thumbrt = $minthumb[0] / $sfile[0];
  } else {
    $thumbrt = $minthumb[1] / $sfile[1];
  }
  my @sthumb = (max(int($sfile[0] * $thumbrt + 0.5), $minthumb[0]),
                max(int($sfile[1] * $thumbrt + 0.5), $minthumb[1]));
  my @mthumb = (min($maxthumb[0], $sthumb[0]), min($maxthumb[1], $sthumb[1]));

  # cropping window
  my $dx = $sthumb[0] - $mthumb[0];
  my $cx = clamp(0, $dx, int($center[0] * $sthumb[0] - $sthumb[0] / 2 + $dx / 2));
  my $dy = $sthumb[1] - $mthumb[1];
  my $cy = clamp(0, $dy, int($center[1] * $sthumb[1] - $sthumb[1] / 2 + $dy / 2));

  sys('convert', '-quiet', $absFtmp,
      '-gamma', '0.454545',
      '-resize', "$sthumb[0]x$sthumb[1]!",
      '-gravity', 'NorthWest',
      '-crop', "$mthumb[0]x$mthumb[1]+$cx+$cy",
      '-gamma', '2.2',
      '+profile', '!icc,*',
      '-quality', $imgq, catfile($absOut, $fthumb)
  );

  # blur
  sys('convert', '-quiet', catfile($absOut, $fthumb),
      '-virtual-pixel', 'Mirror',
      '-gaussian-blur', "0x$backblur",
      '-scale', "$backsize[0]x$backsize[1]",
      '-quality', '90', catfile($absOut, $fblur)
   ) if $do_blur;

  my %fdata;
  $fdata{props} = \%props;
  $fdata{img} = [$fimg, [map { int } @simg]];
  $fdata{file} = [$ffile, [map { int } @sfile]];
  $fdata{blur} = $fblur if $do_blur;

  # do not store duplicate information
  my @tdata = ($fthumb, [map { int } @mthumb]);
  if ($sthumb[0] != $mthumb[0] || $sthumb[1] != $mthumb[1]) {
    push(@tdata, [map { int } @sthumb], [map { int } $cx, $cy]);
  }
  $fdata{thumb} = \@tdata;

  # truncate some floats
  $center[0] = int($center[0] * 1000);
  $center[1] = int($center[1] * 1000);
  if (abs($center[0] - 500) > 1 || abs($center[0] - 500) > 1) {
    $fdata{center} = \@center;
  }

  # remove temporary files
  unlink($absFtmp) if $absFtmp ne $absFout;

  return \%fdata;
}

progress::init("processing", scalar(@aprops));
my @adata = par_map(\&process_img, @aprops);
progress::done();

# sorting
if ($timesort) {
  @adata = sort { $a->{props}{stamp} <=> $b->{props}{stamp} } @adata;
  @adata = reverse @adata if $revsort;
}

# generate zip file
my $fdownload = undef;
if (!$nodown && !$slim)
{
  print("generating archive...\n");

  $fdownload = "files/album.zip";
  my @files = map { catfile($absOut, $_->{file}[0]) } @adata;

  if (!$p7zip) {
    sys('zip', '-q9j', catfile($absOut, $fdownload), @files);
  } else
  {
    # make paths explicitly absolute/relative to strip file path info with 7za
    my $dot = substr($absOut, 0, 1);
    if ($dot ne '/' && $dot ne '.') {
      @files = map { "./$_" } @files;
    }

    my @mt = $workers? ("-mmt=$workers"): ();
    sys('7za', '-tzip', @mt, 'a', '--', catfile($absOut, $fdownload), @files);
  }
}

# remove unnecessary raw files
if (!$ofile || $slim)
{
  for my $fdata(@adata)
  {
    my $file = catfile($absOut, $fdata->{file}[0]);
    my $keep = !$slim && $ofile;

    if (!$slim && !$keep && $fullpano)
    {
      my ($x, $y) = @{$fdata->{file}[1]};
      my $mp = ($x * $y / 1e6);

      # try to see if the source file is just a crop of the original
      my $ox = $fdata->{props}{'OrigImageWidth'} // 0;
      my $oy = $fdata->{props}{'OrigImageHeight'} // 0;
      my $omp = ($ox * $oy / 1e6);

      if ($mp >= $omp && $mp > $amp && abs($x / $y) >= $panort) {
        $keep = 1;
      }
    }

    if (!$keep)
    {
      unlink($file);
      delete($fdata->{file});
    }
  }
}

# only attempt to remove the directory (if empty)
rmdir(catfile($absOut, 'files'));

# generate json
my %json;
$json{version} = $VERSION;
$json{name} = $name if ($name);
$json{download} = $fdownload if ($fdownload);
$json{index} = $indexUrl if ($indexUrl);
$json{blur} = \@backsize if $do_blur;
$json{thumb} = { min => \@minthumb, max => \@maxthumb };

# prepare data.json and print out noscript.html file
init_noscript($absOut);
for my $fdata (@adata) {
  my %data;
  for ( qw(img thumb file blur center) ) {
    $data{$_} = $fdata->{$_} if defined $fdata->{$_};
  }
  for ( qw(date stamp caption) ) {
    $data{$_} = $fdata->{props}{$_} if defined $fdata->{props}{$_};
  }
  push(@{$json{data}}, \%data);
  print_noscript($data{img}->[0], $data{thumb}->[0], $data{caption});
}
finish_noscript();

if ($update) {
  $json{data} = [sort { $a->{stamp} <=> $b->{stamp} } @{$json{data}}, @odata];
}

# write out json
my $fd;
my $dj = catfile($absOut, 'data.json');
fatal("cannot write file '$dj': $!") unless open($fd, ">:raw", $dj);
print $fd
      JSON::PP->new->ascii->pretty->canonical->allow_blessed->encode(\%json);
close $fd;

if ($galleryTitle && $galleryDescription && $galleryUrl) {
  my $id = -1;
  my $html = qq{\n      <div id="photos" itemscope itemtype="http://schema.org/ImageGallery">\n};
  $html .= qq{\t<h1 itemprop="name">$galleryTitle</h1>\n} if $galleryTitle;
  $html .= qq{\t<p itemprop="description">$galleryDescription</p>\n} if $galleryDescription;
  $html .= qq{\t<div id="wrapper">\n};
  $html .= qq{\t  };
  $html .= join("\n\t  ", map {
    $id++;
    my $props = $_->{props};
    my $caption = $props->{caption} ? $props->{caption}[0] : "";
    my $root = $props->{root};
    my $fbase = "$root.$ext";
    my $file = $props->{file};
    # no alt text or title attribute with caption?
    qq{<a id="$id" href="imgs/$fbase" title="$caption">}
    . qq{<img src="thumbs/$fbase" alt="$caption"/></a>}
  } @adata);
  $html .= qq{\n\t</div>\n};
  $html .= qq{      </div>\n};
  $html .= qq{    };
  my $index = slurp(catfile($absOut, 'index.html'));
  $index =~ s@<noscript>.*?</noscript>@<noscript>$html</noscript>@s;

  # default to the first image
  my $galleryImage = $adata[0]->{props}->{root} . ".$ext";
  $html = qq{
    <!-- for Facebook -->
    <meta property="og:title" content="$galleryTitle" />
    <meta property="og:description" content="$galleryDescription" />
    <meta property="og:type" content="article" />
    <meta property="og:image" content="${galleryUrl}imgs/$galleryImage" />
    <meta property="og:url" content="$galleryUrl" />
    <!-- for Twitter -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="$galleryTitle" />
    <meta name="twitter:description" content="$galleryDescription" />
    <meta name="twitter:image" content="${galleryUrl}imgs/$galleryImage" />
  };
  $index =~ s@    <!-- for Facebook -->\n(    .*\n)*@@;
  $index =~ s@  </head>@$html  </head>@;

  fatal("cannot write new index file: $!")
    unless open($fd, ">:encoding($ENCODING)", catfile($absOut, 'index.html'));
  print $fd $index;
  close $fd;
}

print "$0 version $VERSION done for $absOut\n";

exit 0;
